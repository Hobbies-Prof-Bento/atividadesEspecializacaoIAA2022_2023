def bit2vet(valor):
  res = [];
  for i in range(0,32):
    if valor & (0x01<<i) > 0:
      res.insert(0,1);
    else:
      res.insert(0,0);
  return res;
 
 
def bin2num(vet):
  num = 0;
  if vet[0] == 1:
    # num negativos
    for i in range(1,32):
      if vet[i]==0:
        num = num + 2**(31-i);
    num = -1 - num;
  else:
    for i in range(1,32):
      if vet[i]>0:
        num = num + 2**(31-i);
  return num;
 
 
nums = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15]
for n in nums:
  valor_vetor_binario = bit2vet(n)
  print( "{} bin {} num {}".format( n,valor_vetor_binario, bin2num(valor_vetor_binario) ) )
 
# saida esperada:
# 5 bin [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1] num 5  
# para o calculo inverso, convers√£o para decimal, considere:
# 0x2^32 + 0x2^21 ... +1x2^2 + 0x2^1 + 1x2^0 = 1x2^2 + 1x2^0 = 4 + 1 = 5